package hash

// generated by hasher -type=Hash -file=hash.go; DO NOT EDIT, except for adding more constants to the list and rerun go generate

// uses github.com/tdewolff/hasher
//go:generate hasher -type=Hash -file=hash.go

// Hash defines perfect hashes for a predefined list of strings
type Hash uint32

// Unique hash definitions to be used instead of strings
const (
	Cbrt  Hash = 0x904  // cbrt
	Cos   Hash = 0x503  // cos
	Cot   Hash = 0x3    // cot
	Csc   Hash = 0x303  // csc
	Erf   Hash = 0xf03  // erf
	Exp   Hash = 0x1203 // exp
	Ln    Hash = 0x1502 // ln
	Log   Hash = 0x1703 // log
	Log10 Hash = 0x1705 // log10
	Log2  Hash = 0x1c04 // log2
	Sec   Hash = 0x703  // sec
	Sin   Hash = 0x2003 // sin
	Sqrt  Hash = 0x2304 // sqrt
	Tan   Hash = 0xc03  // tan
)

// String returns the hash' name.
func (i Hash) String() string {
	start := uint32(i >> 8)
	n := uint32(i & 0xff)
	if start+n > uint32(len(_Hash_text)) {
		return ""
	}
	return _Hash_text[start : start+n]
}

// ToHash returns the hash whose name is s. It returns zero if there is no
// such hash. It is case sensitive.
func ToHash(s []byte) Hash {
	if len(s) == 0 || len(s) > _Hash_maxLen {
		return 0
	}
	h := uint32(_Hash_hash0)
	for i := 0; i < len(s); i++ {
		h ^= uint32(s[i])
		h *= 16777619
	}
	if i := _Hash_table[h&uint32(len(_Hash_table)-1)]; int(i&0xff) == len(s) {
		t := _Hash_text[i>>8 : i>>8+i&0xff]
		for i := 0; i < len(s); i++ {
			if t[i] != s[i] {
				goto NEXT
			}
		}
		return i
	}
NEXT:
	if i := _Hash_table[(h>>16)&uint32(len(_Hash_table)-1)]; int(i&0xff) == len(s) {
		t := _Hash_text[i>>8 : i>>8+i&0xff]
		for i := 0; i < len(s); i++ {
			if t[i] != s[i] {
				return 0
			}
		}
		return i
	}
	return 0
}

const _Hash_hash0 = 0xf0c5341e
const _Hash_maxLen = 5
const _Hash_text = "cotcscosecbrtanerfexplnlog10log2sinsqrt"

var _Hash_table = [1 << 4]Hash{
	0x1: 0x503,  // cos
	0x2: 0x1c04, // log2
	0x4: 0x1502, // ln
	0x5: 0x1203, // exp
	0x6: 0xf03,  // erf
	0x7: 0x1703, // log
	0x8: 0x303,  // csc
	0x9: 0x904,  // cbrt
	0xa: 0x3,    // cot
	0xb: 0xc03,  // tan
	0xc: 0x2003, // sin
	0xd: 0x1705, // log10
	0xe: 0x2304, // sqrt
	0xf: 0x703,  // sec
}
